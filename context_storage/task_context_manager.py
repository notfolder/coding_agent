"""Task context manager for managing all context-related operations.

This module provides a TaskContextManager class that integrates all context
storage components and manages the task lifecycle.
"""

from __future__ import annotations

import json
import logging
import os
import shutil
from datetime import datetime, timezone
from pathlib import Path
from typing import TYPE_CHECKING, Any

from db.task_db import DBTask, TaskDBManager

from .message_store import MessageStore
from .summary_store import SummaryStore
from .tool_store import ToolStore

if TYPE_CHECKING:
    from handlers.planning_history_store import PlanningHistoryStore
    from handlers.task_key import TaskKey

logger = logging.getLogger(__name__)


class TaskContextManager:
    """Task context manager.
    
    Manages the entire task context including directory structure,
    PostgreSQL database (via TaskDBManager), and all context stores.
    """

    def __init__(
        self,
        task_key: TaskKey,
        task_uuid: str,
        config: dict[str, Any],
        user: str | None = None,
        is_resumed: bool = False,
    ) -> None:
        """Initialize TaskContextManager.

        Args:
            task_key: TaskKey object identifying the task
            task_uuid: UUID for this task (generated by queue)
            config: Configuration dictionary
            user: Username who created the task
            is_resumed: Whether this is a resumed task (default: False)

        """
        self.task_key = task_key
        self.uuid = task_uuid
        self.config = config
        self.user = user
        self.is_resumed = is_resumed
        
        # Setup directories
        context_storage_config = config.get("context_storage", {})
        base_dir = Path(context_storage_config.get("base_dir", "contexts"))
        self.base_dir = base_dir
        self.running_dir = base_dir / "running"
        self.completed_dir = base_dir / "completed"
        self.context_dir = self.running_dir / task_uuid
        
        # Create directories
        self.running_dir.mkdir(parents=True, exist_ok=True)
        self.completed_dir.mkdir(parents=True, exist_ok=True)
        self.context_dir.mkdir(parents=True, exist_ok=True)
        
        # Create planning subdirectory
        self.planning_dir = self.context_dir / "planning"
        self.planning_dir.mkdir(parents=True, exist_ok=True)
        
        # Initialize TaskDBManager for PostgreSQL access
        self._db_manager = TaskDBManager(config)
        # DBTaskインスタンスをキャッシュ
        self._db_task: DBTask | None = None
        
        # LLMクライアントをキャッシュ（要約生成で再利用）
        self._llm_client: Any = None
        
        # 完了時フック関数のリスト
        self._completion_hooks: list[tuple[str, Any]] = []
        
        # 停止時フック関数のリスト（stop()専用）
        self._stop_hooks: list[tuple[str, Any]] = []
        
        # Create metadata.json
        self._create_metadata()
        
        # Initialize stores
        self.message_store = MessageStore(self.context_dir, config)
        self.summary_store = SummaryStore(self.context_dir)
        self.tool_store = ToolStore(self.context_dir)
        
        # Initialize planning store (lazy import to avoid circular dependency)
        from handlers.planning_history_store import PlanningHistoryStore
        self.planning_store = PlanningHistoryStore(task_uuid, self.planning_dir)
        
        # 引き継ぎコンテキストの初期化（リジュームでない新規タスクの場合のみ）
        self.inheritance_context = None
        self.inheritance_manager = None
        if not is_resumed:
            self._init_context_inheritance(task_key, config)
        
        # Register task in database (or update if resumed)
        self._register_or_update_task()

    def _init_context_inheritance(self, task_key: TaskKey, config: dict[str, Any]) -> None:
        """過去コンテキスト引き継ぎを初期化する.

        Args:
            task_key: タスクキー
            config: 設定辞書

        """
        from .context_inheritance_manager import ContextInheritanceManager

        try:
            self.inheritance_manager = ContextInheritanceManager(self.base_dir, config)
            
            # 引き継ぎコンテキストを検索
            inheritance = self.inheritance_manager.get_inheritance_context(task_key)
            
            if inheritance:
                self.inheritance_context = inheritance
                logger.info(
                    "過去コンテキストを引き継ぎます: uuid=%s",
                    inheritance.previous_context.uuid[:8],
                )
        except Exception as e:
            logger.warning("過去コンテキスト引き継ぎの初期化に失敗: %s", e)

    def get_message_store(self) -> MessageStore:
        """Get MessageStore instance.

        Returns:
            MessageStore instance

        """
        return self.message_store

    def get_summary_store(self) -> SummaryStore:
        """Get SummaryStore instance.

        Returns:
            SummaryStore instance

        """
        return self.summary_store

    def get_tool_store(self) -> ToolStore:
        """Get ToolStore instance.

        Returns:
            ToolStore instance

        """
        return self.tool_store

    def get_planning_store(self) -> PlanningHistoryStore:
        """Get PlanningHistoryStore instance.

        Returns:
            PlanningHistoryStore instance

        """
        return self.planning_store

    def set_llm_client(self, llm_client: Any) -> None:
        """Set LLM client for context operations.
        
        Args:
            llm_client: LLMクライアントインスタンス（ユーザー設定を反映したもの）
        
        """
        self._llm_client = llm_client

    def get_inheritance_context(self) -> Any | None:
        """Get inheritance context if available.

        Returns:
            InheritanceContext instance or None if no inheritance

        """
        return self.inheritance_context

    def has_inheritance_context(self) -> bool:
        """Check if inheritance context is available.

        Returns:
            True if inheritance context exists

        """
        return self.inheritance_context is not None

    def get_inheritance_notification_comment(self) -> str | None:
        """Generate notification comment for inheritance.

        Returns:
            Notification comment string or None if no inheritance

        """
        if self.inheritance_context is None or self.inheritance_manager is None:
            return None

        return self.inheritance_manager.generate_notification_comment(
            self.inheritance_context
        )

    def create_initial_context_with_inheritance(
        self, user_request: str
    ) -> list[dict[str, Any]] | None:
        """Create initial context with inheritance if available.

        Args:
            user_request: Current user request (Issue/MR/PR content)

        Returns:
            Initial context messages or None if no inheritance

        """
        if self.inheritance_context is None or self.inheritance_manager is None:
            return None

        return self.inheritance_manager.create_initial_context(
            self.inheritance_context, user_request
        )

    def update_status(self, status: str, error_message: str | None = None) -> None:
        """Update task status in database.

        Args:
            status: New status ("running" | "completed" | "failed")
            error_message: Error message (if status is "failed")

        """
        try:
            # DBTaskを取得（キャッシュがあれば使用）
            if self._db_task is None:
                self._db_task = self._db_manager.get_task(self.uuid)
            
            if self._db_task:
                self._db_task.status = status
                if error_message:
                    self._db_task.error_message = error_message
                self._db_task = self._db_manager.save_task(self._db_task)
                logger.debug("タスクステータスを更新しました: uuid=%s, status=%s", self.uuid, status)
        except Exception as e:
            logger.error("タスクステータスの更新に失敗しました: %s", e, exc_info=True)

    def update_statistics(
        self,
        llm_calls: int = 0,
        tool_calls: int = 0,
        tokens: int = 0,
        compressions: int = 0,
    ) -> None:
        """Update statistics in database.

        Args:
            llm_calls: Number of LLM calls to add
            tool_calls: Number of tool calls to add
            tokens: Number of tokens to add
            compressions: Number of compressions to add

        """
        try:
            # DBTaskを取得（キャッシュがあれば使用）
            if self._db_task is None:
                self._db_task = self._db_manager.get_task(self.uuid)
            
            if self._db_task:
                # 統計情報を加算
                self._db_task.llm_call_count = (self._db_task.llm_call_count or 0) + llm_calls
                self._db_task.tool_call_count = (self._db_task.tool_call_count or 0) + tool_calls
                self._db_task.total_tokens = (self._db_task.total_tokens or 0) + tokens
                self._db_task.compression_count = (self._db_task.compression_count or 0) + compressions
                self._db_task = self._db_manager.save_task(self._db_task)
                logger.debug(
                    "タスク統計を更新しました: uuid=%s, llm=%d, tool=%d, tokens=%d, compressions=%d",
                    self.uuid, llm_calls, tool_calls, tokens, compressions,
                )
            else:
                logger.warning(
                    "DBTaskが見つからないため統計を更新できませんでした: uuid=%s, llm=%d, tool=%d, tokens=%d, compressions=%d",
                    self.uuid, llm_calls, tool_calls, tokens, compressions,
                )
        except Exception as e:
            logger.error(
                "タスク統計の更新に失敗しました: uuid=%s, llm=%d, tool=%d, tokens=%d, compressions=%d, error=%s",
                self.uuid, llm_calls, tool_calls, tokens, compressions, e,
                exc_info=True,
            )

    def register_completion_hook(self, hook_name: str, hook_func: Any) -> None:
        """完了時に実行するフック関数を登録.
        
        Args:
            hook_name: フック関数の識別名（ログ用）
            hook_func: 引数なしで呼び出し可能なフック関数
        """
        self._completion_hooks.append((hook_name, hook_func))
        logger.debug("完了フックを登録しました: %s", hook_name)
    
    def register_stop_hook(self, hook_name: str, hook_func: Any) -> None:
        """停止時に実行するフック関数を登録.
        
        Args:
            hook_name: フック関数の識別名（ログ用）
            hook_func: 引数なしで呼び出し可能なフック関数
        """
        self._stop_hooks.append((hook_name, hook_func))
        logger.debug("停止フックを登録しました: %s", hook_name)

    def complete(self) -> None:
        """Mark task as completed and move to completed directory.
        
        処理順序:
        1. 最終要約作成
        2. 完了フックの実行
        3. データベース更新
        4. ディレクトリ移動
        
        """
        # 1. タスク完了時に最終要約を作成
        self._create_final_summary()
        
        # 2. 登録された完了フック関数を実行
        for hook_name, hook_func in self._completion_hooks:
            try:
                logger.info("完了フック実行中: %s", hook_name)
                hook_func()
                logger.info("完了フック実行完了: %s", hook_name)
            except Exception as e:
                logger.warning("完了フック実行失敗 (%s): %s", hook_name, e, exc_info=True)
        
        # 3-4. データベース更新とディレクトリ移動
        self._finalize_task_db_and_move("completed")

    def stop(self) -> None:
        """Mark task as stopped by user and move to completed directory.
        
        処理順序:
        1. 最終要約作成
        2. 停止専用フックの実行
        3. データベース更新
        4. ディレクトリ移動
        
        """
        # 1. タスク停止時に最終要約を作成
        self._create_final_summary()
        
        # 2. 登録された停止フック関数を実行
        for hook_name, hook_func in self._stop_hooks:
            try:
                logger.info("停止フック実行中: %s", hook_name)
                hook_func()
                logger.info("停止フック実行完了: %s", hook_name)
            except Exception as e:
                logger.warning("停止フック実行失敗 (%s): %s", hook_name, e, exc_info=True)
        
        # 3-4. データベース更新とディレクトリ移動
        self._finalize_task_db_and_move("stopped")

    def _finalize_task_db_and_move(self, status: str, error_message: str | None = None) -> None:
        """Finalize task database and directory (called after hooks).

        Args:
            status: Final status ("completed", "stopped", or "failed")
            error_message: Error message (only for failed status)

        """
        # Update database
        try:
            # DBTaskを取得（キャッシュがあれば使用）
            if self._db_task is None:
                self._db_task = self._db_manager.get_task(self.uuid)
            
            if self._db_task:
                self._db_task.status = status
                if error_message and status == "failed":
                    self._db_task.error_message = error_message
                self._db_task.completed_at = datetime.now(timezone.utc)
                self._db_task = self._db_manager.save_task(self._db_task)
            
            if error_message:
                logger.info("タスクを%sとしてデータベースに記録しました: uuid=%s, error=%s", status, self.uuid, error_message)
            else:
                logger.info("タスクを%sとしてデータベースに記録しました: uuid=%s", status, self.uuid)
        except Exception as e:
            logger.error("タスク%sのデータベース更新に失敗しました: %s", status, e, exc_info=True)
        
        # Move directory
        target_dir = self.completed_dir / self.uuid
        if self.context_dir.exists():
            shutil.move(str(self.context_dir), str(target_dir))
        self.context_dir = target_dir

    def fail(self, error_message: str) -> None:
        """Mark task as failed and move to completed directory.

        処理順序:
        1. 最終要約作成
        2. 完了フックの実行
        3. データベース更新
        4. ディレクトリ移動

        Args:
            error_message: Error message describing the failure

        """
        # 1. タスク失敗時にも最終要約を作成
        self._create_final_summary()
        
        # 2. 登録された完了フック関数を実行
        for hook_name, hook_func in self._completion_hooks:
            try:
                logger.info("完了フック実行中（失敗時）: %s", hook_name)
                hook_func()
                logger.info("完了フック実行完了（失敗時）: %s", hook_name)
            except Exception as e:
                logger.warning("完了フック実行失敗 (%s): %s", hook_name, e, exc_info=True)
        
        # 3-4. データベース更新とディレクトリ移動
        self._finalize_task_db_and_move("failed", error_message=error_message)

    def _create_final_summary(self) -> None:
        """タスク完了/失敗時に最終要約を作成する."""
        # メッセージ数を確認
        message_count = self.message_store.count_messages()
        if message_count == 0:
            logger.info("メッセージがないため最終要約をスキップします")
            return
        
        try:
            # LLMクライアントを取得または再利用（ユーザー設定を保持）
            if self._llm_client is None:
                from clients.lm_client import get_llm_client
                llm_client = get_llm_client(
                    self.config,
                    message_store=self.message_store,
                    context_dir=self.context_dir,
                )
            else:
                # 既存のLLMクライアントを再利用（ユーザー設定が反映されている）
                llm_client = self._llm_client
            
            # ContextCompressorを初期化
            from .context_compressor import ContextCompressor
            compressor = ContextCompressor(
                self.message_store,
                self.summary_store,
                llm_client,
                self.config,
            )
            
            # 最終要約を作成（全メッセージを対象とした要約）
            logger.info("タスク完了時の最終要約を作成します: uuid=%s, messages=%d", self.uuid, message_count)
            summary_id = compressor.create_final_summary()
            
            if summary_id < 0:
                logger.warning("最終要約の作成がスキップされました（メッセージなし）")
            else:
                logger.info("最終要約の作成が完了しました: summary_id=%d", summary_id)
        except Exception as e:
            # 要約作成失敗は致命的エラーではないため警告ログのみ
            logger.warning("最終要約の作成に失敗しました: %s", e, exc_info=True)

    def _create_metadata(self) -> None:
        """Create metadata.json file."""
        llm_config = self.config.get("llm", {})
        provider = llm_config.get("provider", "openai")
        provider_config = llm_config.get(provider, {})
        
        context_storage_config = self.config.get("context_storage", {})
        
        metadata = {
            "uuid": self.uuid,
            "task_key": self.task_key.to_dict(),
            "created_at": datetime.now(timezone.utc).isoformat(),
            "process_id": os.getpid(),
            "hostname": os.uname().nodename,
            "config": {
                "llm_provider": provider,
                "model": provider_config.get("model", "unknown"),
                "context_length": provider_config.get("context_length", 128000),
                "compression_threshold": context_storage_config.get("compression_threshold", 0.7),
            },
            "user": self.user,
        }
        
        metadata_file = self.context_dir / "metadata.json"
        with metadata_file.open("w") as f:
            json.dump(metadata, f, indent=2)

    def _register_or_update_task(self) -> None:
        """Register task in database, or update if resumed.
        
        TaskDBManagerを使用してPostgreSQLにタスク情報を登録/更新します。
        """
        try:
            llm_config = self.config.get("llm", {})
            provider = llm_config.get("provider", "openai")
            provider_config = llm_config.get(provider, {})
            
            task_dict = self.task_key.to_dict()
            
            # TaskKeyのto_dict()から、データベース形式に変換
            # type: "github_issue" -> task_source: "github", task_type: "issue"
            # type: "gitlab_issue" -> task_source: "gitlab", task_type: "issue"
            task_type_full = task_dict.get("type", "unknown")
            if "_" in task_type_full:
                parts = task_type_full.split("_", 1)
                task_source = parts[0]
                task_type = parts[1]
            else:
                task_source = task_type_full
                task_type = task_type_full
            
            # フィールドの抽出
            owner = task_dict.get("owner")
            repo = task_dict.get("repo")
            project_id = task_dict.get("project_id")
            number = 0
            
            if task_source == "gitlab":
                # issue_iid または mr_iid を取得（Noneの場合は0）
                issue_iid = task_dict.get("issue_iid")
                mr_iid = task_dict.get("mr_iid")
                number = int(issue_iid if issue_iid is not None else (mr_iid if mr_iid is not None else 0))
            else:
                number = int(task_dict.get("number", 0))
            
            now = datetime.now(timezone.utc)
            
            if self.is_resumed:
                # 既存タスクを取得して更新
                self._db_task = self._db_manager.get_task(self.uuid)
                if self._db_task:
                    self._db_task.status = "running"
                    self._db_task.started_at = now
                    self._db_task.process_id = os.getpid()
                    self._db_task.hostname = os.uname().nodename
                    self._db_task = self._db_manager.save_task(self._db_task)
            else:
                # 新規タスクを作成
                task_data = {
                    "uuid": self.uuid,
                    "task_source": task_source,
                    "task_type": task_type,
                    "owner": owner,
                    "repo": repo,
                    "project_id": int(project_id) if project_id is not None else None,
                    "number": number,
                    "status": "running",
                    "created_at": now,
                    "started_at": now,
                    "process_id": os.getpid(),
                    "hostname": os.uname().nodename,
                    "llm_provider": provider,
                    "model": provider_config.get("model", "unknown"),
                    "context_length": provider_config.get("context_length", 128000),
                    "user": self.user,
                    "llm_call_count": 0,
                    "tool_call_count": 0,
                    "total_tokens": 0,
                    "compression_count": 0,
                }
                self._db_task = self._db_manager.create_task(task_data)
            
            logger.info(
                "タスクをデータベースに登録しました: uuid=%s, source=%s, type=%s, number=%d",
                self.uuid,
                task_source,
                task_type,
                number,
            )
        except Exception as e:
            logger.error(
                "タスクのデータベース登録に失敗しました: uuid=%s, error=%s", 
                self.uuid, 
                e, 
                exc_info=True,
            )
            logger.error(
                "データベース設定を確認してください: host=%s, port=%s, name=%s, user=%s",
                self.config.get("database", {}).get("host"),
                self.config.get("database", {}).get("port"),
                self.config.get("database", {}).get("name"),
                self.config.get("database", {}).get("user"),
            )
            # DB登録失敗時もタスク処理は継続（統計記録はできないが処理は可能）
            # 警告: この場合、統計情報はDBに記録されません
            logger.warning("統計情報はデータベースに記録されません")
