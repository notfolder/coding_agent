"""Task context manager for managing all context-related operations.

This module provides a TaskContextManager class that integrates all context
storage components and manages the task lifecycle.
"""

from __future__ import annotations

import json
import os
import shutil
import sqlite3
from datetime import datetime, timezone
from pathlib import Path
from typing import TYPE_CHECKING, Any

from .message_store import MessageStore
from .summary_store import SummaryStore
from .tool_store import ToolStore

if TYPE_CHECKING:
    from handlers.task_key import TaskKey
    from handlers.planning_history_store import PlanningHistoryStore


class TaskContextManager:
    """Task context manager.
    
    Manages the entire task context including directory structure,
    SQLite database, and all context stores.
    """

    def __init__(self, task_key: TaskKey, task_uuid: str, config: dict[str, Any], user: str | None = None, is_resumed: bool = False) -> None:
        """Initialize TaskContextManager.

        Args:
            task_key: TaskKey object identifying the task
            task_uuid: UUID for this task (generated by queue)
            config: Configuration dictionary
            user: Username who created the task
            is_resumed: Whether this is a resumed task (default: False)

        """
        self.task_key = task_key
        self.uuid = task_uuid
        self.config = config
        self.user = user
        self.is_resumed = is_resumed
        
        # Setup directories
        context_storage_config = config.get("context_storage", {})
        base_dir = Path(context_storage_config.get("base_dir", "contexts"))
        self.base_dir = base_dir
        self.running_dir = base_dir / "running"
        self.completed_dir = base_dir / "completed"
        self.context_dir = self.running_dir / task_uuid
        
        # Create directories
        self.running_dir.mkdir(parents=True, exist_ok=True)
        self.completed_dir.mkdir(parents=True, exist_ok=True)
        self.context_dir.mkdir(parents=True, exist_ok=True)
        
        # Create planning subdirectory
        self.planning_dir = self.context_dir / "planning"
        self.planning_dir.mkdir(parents=True, exist_ok=True)
        
        # Initialize database
        self.db_path = base_dir / "tasks.db"
        self._init_database()
        
        # Create metadata.json
        self._create_metadata()
        
        # Initialize stores
        self.message_store = MessageStore(self.context_dir, config)
        self.summary_store = SummaryStore(self.context_dir)
        self.tool_store = ToolStore(self.context_dir)
        
        # Initialize planning store (lazy import to avoid circular dependency)
        from handlers.planning_history_store import PlanningHistoryStore
        self.planning_store = PlanningHistoryStore(task_uuid, self.planning_dir)
        
        # 引き継ぎコンテキストの初期化（リジュームでない新規タスクの場合のみ）
        self.inheritance_context = None
        self.inheritance_manager = None
        if not is_resumed:
            self._init_context_inheritance(task_key, config)
        
        # Register task in database (or update if resumed)
        self._register_or_update_task()

    def _init_context_inheritance(self, task_key: TaskKey, config: dict[str, Any]) -> None:
        """過去コンテキスト引き継ぎを初期化する.

        Args:
            task_key: タスクキー
            config: 設定辞書

        """
        import logging
        from .context_inheritance_manager import ContextInheritanceManager

        logger = logging.getLogger(__name__)

        try:
            self.inheritance_manager = ContextInheritanceManager(self.base_dir, config)
            
            # 引き継ぎコンテキストを検索
            inheritance = self.inheritance_manager.get_inheritance_context(task_key)
            
            if inheritance:
                self.inheritance_context = inheritance
                logger.info(
                    "過去コンテキストを引き継ぎます: uuid=%s",
                    inheritance.previous_context.uuid[:8],
                )
        except Exception as e:
            logger.warning("過去コンテキスト引き継ぎの初期化に失敗: %s", e)

    def get_message_store(self) -> MessageStore:
        """Get MessageStore instance.

        Returns:
            MessageStore instance

        """
        return self.message_store

    def get_summary_store(self) -> SummaryStore:
        """Get SummaryStore instance.

        Returns:
            SummaryStore instance

        """
        return self.summary_store

    def get_tool_store(self) -> ToolStore:
        """Get ToolStore instance.

        Returns:
            ToolStore instance

        """
        return self.tool_store

    def get_planning_store(self) -> PlanningHistoryStore:
        """Get PlanningHistoryStore instance.

        Returns:
            PlanningHistoryStore instance

        """
        return self.planning_store

    def get_inheritance_context(self) -> Any | None:
        """Get inheritance context if available.

        Returns:
            InheritanceContext instance or None if no inheritance

        """
        return self.inheritance_context

    def has_inheritance_context(self) -> bool:
        """Check if inheritance context is available.

        Returns:
            True if inheritance context exists

        """
        return self.inheritance_context is not None

    def get_inheritance_notification_comment(self) -> str | None:
        """Generate notification comment for inheritance.

        Returns:
            Notification comment string or None if no inheritance

        """
        if self.inheritance_context is None or self.inheritance_manager is None:
            return None

        return self.inheritance_manager.generate_notification_comment(
            self.inheritance_context
        )

    def create_initial_context_with_inheritance(
        self, user_request: str
    ) -> list[dict[str, Any]] | None:
        """Create initial context with inheritance if available.

        Args:
            user_request: Current user request (Issue/MR/PR content)

        Returns:
            Initial context messages or None if no inheritance

        """
        if self.inheritance_context is None or self.inheritance_manager is None:
            return None

        return self.inheritance_manager.create_initial_context(
            self.inheritance_context, user_request
        )

    def update_status(self, status: str, error_message: str | None = None) -> None:
        """Update task status in database.

        Args:
            status: New status ("running" | "completed" | "failed")
            error_message: Error message (if status is "failed")

        """
        with sqlite3.connect(self.db_path) as conn:
            cursor = conn.cursor()
            if error_message:
                cursor.execute(
                    "UPDATE tasks SET status = ?, error_message = ? WHERE uuid = ?",
                    (status, error_message, self.uuid),
                )
            else:
                cursor.execute(
                    "UPDATE tasks SET status = ? WHERE uuid = ?",
                    (status, self.uuid),
                )
            conn.commit()

    def update_statistics(
        self,
        llm_calls: int = 0,
        tool_calls: int = 0,
        tokens: int = 0,
        compressions: int = 0,
    ) -> None:
        """Update statistics in database.

        Args:
            llm_calls: Number of LLM calls to add
            tool_calls: Number of tool calls to add
            tokens: Number of tokens to add
            compressions: Number of compressions to add

        """
        with sqlite3.connect(self.db_path) as conn:
            cursor = conn.cursor()
            cursor.execute(
                """UPDATE tasks SET 
                   llm_call_count = llm_call_count + ?,
                   tool_call_count = tool_call_count + ?,
                   total_tokens = total_tokens + ?,
                   compression_count = compression_count + ?
                   WHERE uuid = ?""",
                (llm_calls, tool_calls, tokens, compressions, self.uuid),
            )
            conn.commit()

    def complete(self) -> None:
        """Mark task as completed and move to completed directory."""
        # Update database
        with sqlite3.connect(self.db_path) as conn:
            cursor = conn.cursor()
            cursor.execute(
                "UPDATE tasks SET status = ?, completed_at = ? WHERE uuid = ?",
                ("completed", datetime.now(timezone.utc).isoformat(), self.uuid),
            )
            conn.commit()
        
        # Move directory
        target_dir = self.completed_dir / self.uuid
        if self.context_dir.exists():
            shutil.move(str(self.context_dir), str(target_dir))
        self.context_dir = target_dir

    def fail(self, error_message: str) -> None:
        """Mark task as failed and move to completed directory.

        Args:
            error_message: Error message describing the failure

        """
        # Update database
        with sqlite3.connect(self.db_path) as conn:
            cursor = conn.cursor()
            cursor.execute(
                "UPDATE tasks SET status = ?, error_message = ?, completed_at = ? WHERE uuid = ?",
                ("failed", error_message, datetime.now(timezone.utc).isoformat(), self.uuid),
            )
            conn.commit()
        
        # Move directory
        target_dir = self.completed_dir / self.uuid
        if self.context_dir.exists():
            shutil.move(str(self.context_dir), str(target_dir))
        self.context_dir = target_dir

    def _init_database(self) -> None:
        """Initialize SQLite database and create tables if needed."""
        with sqlite3.connect(self.db_path) as conn:
            cursor = conn.cursor()
            
            # Create tasks table
            cursor.execute("""
                CREATE TABLE IF NOT EXISTS tasks (
                    uuid TEXT PRIMARY KEY,
                    task_source TEXT NOT NULL,
                    owner TEXT NOT NULL,
                    repo TEXT NOT NULL,
                    task_type TEXT NOT NULL,
                    task_id TEXT NOT NULL,
                    status TEXT NOT NULL,
                    created_at TEXT NOT NULL,
                    started_at TEXT,
                    completed_at TEXT,
                    process_id INTEGER,
                    hostname TEXT,
                    llm_provider TEXT,
                    model TEXT,
                    context_length INTEGER,
                    llm_call_count INTEGER DEFAULT 0,
                    tool_call_count INTEGER DEFAULT 0,
                    total_tokens INTEGER DEFAULT 0,
                    compression_count INTEGER DEFAULT 0,
                    error_message TEXT,
                    user TEXT
                )
            """)
            
            # Create indexes
            cursor.execute("CREATE INDEX IF NOT EXISTS idx_tasks_status ON tasks(status)")
            cursor.execute("CREATE INDEX IF NOT EXISTS idx_tasks_created_at ON tasks(created_at)")
            cursor.execute("CREATE INDEX IF NOT EXISTS idx_tasks_user ON tasks(user)")
            
            conn.commit()

    def _create_metadata(self) -> None:
        """Create metadata.json file."""
        llm_config = self.config.get("llm", {})
        provider = llm_config.get("provider", "openai")
        provider_config = llm_config.get(provider, {})
        
        context_storage_config = self.config.get("context_storage", {})
        
        metadata = {
            "uuid": self.uuid,
            "task_key": self.task_key.to_dict(),
            "created_at": datetime.now(timezone.utc).isoformat(),
            "process_id": os.getpid(),
            "hostname": os.uname().nodename,
            "config": {
                "llm_provider": provider,
                "model": provider_config.get("model", "unknown"),
                "context_length": provider_config.get("context_length", 128000),
                "compression_threshold": context_storage_config.get("compression_threshold", 0.7),
            },
            "user": self.user,
        }
        
        metadata_file = self.context_dir / "metadata.json"
        with metadata_file.open("w") as f:
            json.dump(metadata, f, indent=2)

    def _register_or_update_task(self) -> None:
        """Register task in database, or update if resumed."""
        llm_config = self.config.get("llm", {})
        provider = llm_config.get("provider", "openai")
        provider_config = llm_config.get(provider, {})
        
        task_dict = self.task_key.to_dict()
        
        with sqlite3.connect(self.db_path) as conn:
            cursor = conn.cursor()
            
            if self.is_resumed:
                # Update existing task record for resumed task
                cursor.execute(
                    """UPDATE tasks SET
                        status = ?,
                        started_at = ?,
                        process_id = ?,
                        hostname = ?
                    WHERE uuid = ?""",
                    (
                        "running",
                        datetime.now(timezone.utc).isoformat(),
                        os.getpid(),
                        os.uname().nodename,
                        self.uuid,
                    ),
                )
            else:
                # Insert new task record
                cursor.execute(
                    """INSERT INTO tasks (
                        uuid, task_source, owner, repo, task_type, task_id,
                        status, created_at, started_at, process_id, hostname,
                        llm_provider, model, context_length, user
                    ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)""",
                    (
                        self.uuid,
                        task_dict.get("task_source", "unknown"),
                        task_dict.get("owner", "unknown"),
                        task_dict.get("repo", "unknown"),
                        task_dict.get("task_type", "unknown"),
                        task_dict.get("task_id", "unknown"),
                        "running",
                        datetime.now(timezone.utc).isoformat(),
                        datetime.now(timezone.utc).isoformat(),
                        os.getpid(),
                        os.uname().nodename,
                        provider,
                        provider_config.get("model", "unknown"),
                        provider_config.get("context_length", 128000),
                        self.user,
                    ),
                )
            conn.commit()
