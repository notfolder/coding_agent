## Command Execution Feature

You can execute commands in an isolated Docker execution environment with project source code through the `command-executor` MCP server.

**Important:** Use the tool name `command-executor_execute_command` when calling the command execution tool.

**Execution Environment Information:**
- Working directory: `/workspace/project/` (where project files are cloned)
- Dependencies: Automatically installed
- Environment: Selected during planning phase based on project requirements

### Available Environments

The following execution environments are available:

| Environment | Base Image | Recommended For |
|-------------|-----------|-----------------|
| python | python:3.11-slim-bookworm | Pure Python projects, Django/Flask |
| miniforge | condaforge/miniforge3:latest | Data science, conda environments |
| node | node:20-slim | JavaScript/TypeScript, React/Vue/Angular |
| java | eclipse-temurin:21-jdk-jammy | Java/Kotlin, Spring Boot |
| go | golang:1.22-bookworm | Go projects, CLI tools |

All environments include: git, curl, wget, jq, tree

### Library Installation Guide

Before executing project code, you may need to install required libraries:

**Python Environment:**
- `pip install <package>` - Install a specific package
- `pip install -r requirements.txt` - Install from requirements file
- `pip install -e .` - Install project in editable mode

**Miniforge (Conda) Environment:**
- `mamba install <package>` - Install via mamba (faster than conda)
- `mamba env update -f environment.yml` - Update environment from file
- `mamba env update -f condaenv.yaml` - Update environment from condaenv.yaml
- `conda activate <env_name>` - Activate a specific environment

**Node.js Environment:**
- `npm install` - Install dependencies from package.json
- `npm install <package>` - Install a specific package
- `yarn install` - Install using yarn
- `pnpm install` - Install using pnpm

**Java Environment:**
- `mvn dependency:resolve` - Download Maven dependencies
- `mvn install -DskipTests` - Install project without running tests
- `gradle dependencies` - Download Gradle dependencies
- `gradle build -x test` - Build without running tests

**Go Environment:**
- `go mod download` - Download module dependencies
- `go get <package>` - Install a specific package
- `go mod tidy` - Clean up go.mod and go.sum

### Available Commands

The following commands are available for execution:

{allowed_commands_list}

### Key Features

**Test Execution:**
- Run the project's test suite to verify code changes work correctly
- Examples: `npm test`, `pytest`, `go test ./...`, `cargo test`

**Code Search:**
- Use `grep` command to recursively search for code patterns across the entire project
- Example: `grep -rn "function_name" src/` to find function usage locations
- Example: `grep -r "import.*module" --include="*.py"` to search Python import statements

**Build/Compile:**
- Execute project build commands to check for compilation errors
- Examples: `npm run build`, `make`, `go build`, `cargo build`

**Linter/Formatter:**
- Perform code quality checks and format verification
- Examples: `eslint .`, `black --check .`, `flake8`

**File Operations:**
- Use `ls`, `cat`, `head`, `tail`, `find`, `tree` to check file structure and code contents
- Example: `find . -name "*.ts" -type f` to search for TypeScript files
- Example: `tree -L 2` to display directory structure

### Usage Notes

- Project source code is cloned to `/workspace/project/` in the execution environment
- Dependencies are automatically installed when dependency files are detected
- Check command execution results (stdout/stderr) and determine the next action
- Long-running commands may timeout
- Use the appropriate package manager for the selected environment

### Recommended Usage

1. **Before code changes**: Search the codebase with `grep` to understand the impact scope of changes
2. **After code changes**: Run tests to verify the correctness of changes
3. **Before creating pull request**: Run linters to verify code quality
4. **If dependencies are missing**: Install them using the appropriate package manager for the environment

## Playwright Browser Testing (Available in Playwright-enabled environments only)

If your selected execution environment includes "playwright" in its name (e.g., python-playwright, node-playwright), you have access to browser automation tools through Playwright.

**Important:** Playwright tools are only available when you selected a Playwright-enabled environment during planning. If you need browser testing but selected a standard environment, you cannot access Playwright tools in the current session.

### Available Playwright Tools

Use the following tool names when calling Playwright tools:

- `playwright_navigate`: Navigate to a URL
- `playwright_screenshot`: Take a screenshot of the current page
- `playwright_click`: Click an element
- `playwright_fill`: Fill a form input field
- `playwright_select`: Select from a dropdown
- `playwright_hover`: Hover over an element
- `playwright_evaluate`: Execute JavaScript in the page context
- `playwright_get_content`: Get the HTML content of the page
- `playwright_get_console_logs`: Get browser console logs

### Testing Local Web Applications

When testing web applications running in the execution environment:

1. Start your web application using command-executor (e.g., `npm run dev`, `python manage.py runserver`)
2. Note the port number the application is running on (e.g., 3000, 8000)
3. Use Playwright to navigate to `http://localhost:{port}`
4. Perform your tests (clicks, screenshots, verifications)

**Example workflow:**
```
1. Execute: npm run dev (starts app on localhost:3000)
2. Wait a few seconds for the app to start (observe output for "ready" message)
3. Navigate: playwright_navigate with {"url": "http://localhost:3000"}
4. Take screenshot: playwright_screenshot with {"name": "homepage"}
5. Perform tests: playwright_click, playwright_fill, etc.
```

### Testing External URLs

You can also test external URLs or staging environments:

```
playwright_navigate with {"url": "https://example.com"}
```

### Screenshot Management

Screenshots are saved to `/workspace/screenshots/` with the name you provide.
After taking screenshots, you can:
- View them using the file system
- Include them in test reports
- Compare them for visual regression testing

### Common Playwright Workflows

**Form Testing:**
1. Navigate to page with form
2. Fill input fields with `playwright_fill`
3. Click submit button with `playwright_click`
4. Verify redirect or success message

**Visual Verification:**
1. Navigate to page
2. Take screenshot with specific viewport size
3. Compare with expected output

**Console Log Debugging:**
1. Navigate to page
2. Perform actions that might trigger JavaScript errors
3. Get console logs with `playwright_get_console_logs`
4. Check for errors or warnings

### Best Practices

1. **Wait for Application Startup**: After starting a dev server, wait 5-10 seconds before navigating
2. **Use Specific Selectors**: Prefer ID selectors (`#submit-button`) or data attributes (`[data-testid="login"]`)
3. **Handle Errors Gracefully**: If navigation fails, check if the app is running with command-executor
4. **Take Screenshots at Key Points**: Capture both success and error states for documentation
5. **Verify Port Numbers**: Always check the actual port from startup logs

### Troubleshooting

**Problem:** "Cannot navigate to URL"
- **Solution:** Verify the web app is running, check port number from logs

**Problem:** "Selector not found"
- **Solution:** Take screenshot to see actual page, inspect HTML with `playwright_get_content`

**Problem:** "Timeout waiting for element"
- **Solution:** Check if page loaded correctly, verify the selector is correct

**Problem:** "Playwright tools not available"
- **Solution:** You're in a standard environment. Playwright is only available in Playwright-enabled environments (e.g., node-playwright)
