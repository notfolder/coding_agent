## Command Execution Feature

You can execute commands in an isolated Docker execution environment with project source code through the `command-executor` MCP server.

**Important:** Use the tool name `command-executor_execute_command` when calling the command execution tool.

**Execution Environment Information:**
- Working directory: `/workspace/project/` (where project files are cloned)
- Dependencies: Automatically installed
- Environment: Selected during planning phase based on project requirements

### Available Environments

The following execution environments are available:

| Environment | Base Image | Recommended For |
|-------------|-----------|------------------|
| python | python:3.11-slim-bookworm | Pure Python projects, Django/Flask |
| miniforge | condaforge/miniforge3:latest | Data science, conda environments |
| node | node:20-slim | JavaScript/TypeScript, React/Vue/Angular |

All environments include: git, curl, wget, jq, tree

### Library Installation Guide

Before executing project code, you may need to install required libraries:

**Python Environment:**
- `pip install <package>` - Install a specific package
- `pip install -r requirements.txt` - Install from requirements file
- `pip install -e .` - Install project in editable mode

**Miniforge (Conda) Environment:**
- `mamba install <package>` - Install via mamba (faster than conda)
- `mamba env update -f environment.yml` - Update environment from file
- `mamba env update -f condaenv.yaml` - Update environment from condaenv.yaml
- `conda activate <env_name>` - Activate a specific environment

**Node.js Environment:**
- `npm install` - Install dependencies from package.json
- `npm install <package>` - Install a specific package
- `yarn install` - Install using yarn
- `pnpm install` - Install using pnpm

### Available Commands

The following commands are available for execution:

{allowed_commands_list}

### Key Features

**Test Execution:**
- Run the project's test suite to verify code changes work correctly
- Examples: `npm test`, `pytest`, `cargo test`

**Code Search:**
- Use `grep` command to recursively search for code patterns across the entire project
- Example: `grep -rn "function_name" src/` to find function usage locations
- Example: `grep -r "import.*module" --include="*.py"` to search Python import statements

**Build/Compile:**
- Execute project build commands to check for compilation errors
- Examples: `npm run build`, `make`, `cargo build`

**Linter/Formatter:**
- Perform code quality checks and format verification
- Examples: `eslint .`, `black --check .`, `flake8`

**File Operations:**
- Use `ls`, `cat`, `head`, `tail`, `find`, `tree` to check file structure and code contents
- Example: `find . -name "*.ts" -type f` to search for TypeScript files
- Example: `tree -L 2` to display directory structure

### Usage Notes

- Project source code is cloned to `/workspace/project/` in the execution environment
- Dependencies are automatically installed when dependency files are detected
- Check command execution results (stdout/stderr) and determine the next action
- Long-running commands may timeout
- Use the appropriate package manager for the selected environment

### Recommended Usage

1. **Before code changes**: Search the codebase with `grep` to understand the impact scope of changes
2. **After code changes**: Run tests to verify the correctness of changes
3. **Before creating pull request**: Run linters to verify code quality
4. **If dependencies are missing**: Install them using the appropriate package manager for the environment
